<?php
/**
 * Extract critical (above-the-fold) CSS from style.css
 * Generates: public/css/critical.css (then minified by minify_css.php)
 *
 * Critical CSS includes only what's needed for first paint:
 * variables, reset, base, container, gradient-text, buttons, navbar, hero,
 * animate-in classes, and mobile media queries for navbar/hero.
 */

$base = dirname(__DIR__);
$input  = $base . '/public/css/style.css';
$output = $base . '/public/css/critical.css';

if (!file_exists($input)) {
    echo "ERROR: $input not found\n";
    exit(1);
}

$css = file_get_contents($input);

$sections = [];

// 1. CSS Custom Properties (:root)
$sections[] = extract_block($css, ':root {');

// 2. Reset & Base — *, html, body, img, a
$sections[] = extract_range($css, '/* --- Reset & Base --- */', '/* --- Utility --- */');

// 3. Utility — .container, .gradient-text, .sr-only
$sections[] = extract_range($css, '/* --- Utility --- */', '/* --- Buttons --- */');

// 4. Buttons — .btn and all variants (used in hero and cookie banner)
$sections[] = extract_range($css, '/* --- Buttons --- */', "/* ========================================\n   NAVBAR");

// 5. Navbar (complete)
$sections[] = extract_range($css, "/* ========================================\n   NAVBAR\n   ======================================== */", "/* ========================================\n   HERO");

// 6. Hero (complete)
$sections[] = extract_range($css, "/* ========================================\n   HERO\n   ======================================== */", "/* ========================================\n   SECTIONS");

// 7. Mobile responsive for navbar/hero — extract from the main responsive block
// We need the 768px and 480px queries for navbar toggle and hero adjustments
$responsive_768 = extract_media_rules($css, '768px', [
    '.navbar__links', '.navbar__lang', '.navbar__toggle',
    '.hero__content', '.cookie-banner',
]);
if ($responsive_768) {
    $sections[] = "@media (max-width: 768px) {\n" . $responsive_768 . "}\n";
}

$responsive_480 = extract_media_rules($css, '480px', [
    '.hero__title', '.hero__cta',
]);
if ($responsive_480) {
    $sections[] = "@media (max-width: 480px) {\n" . $responsive_480 . "}\n";
}

// 8. Mobile overlay (needed for menu)
$sections[] = extract_range($css, '/* --- Mobile menu overlay --- */', '/* --- Selection --- */');

// Build output
$critical = "/* Critical CSS — auto-generated by extract_critical_css.php */\n";
foreach ($sections as $section) {
    $trimmed = trim($section);
    if (!empty($trimmed)) {
        $critical .= "\n" . $trimmed . "\n";
    }
}

file_put_contents($output, $critical);
$size = strlen($critical);
echo "Critical CSS extracted: public/css/critical.css\n";
echo "Size: " . number_format($size) . " bytes\n";

// --- Helper functions ---

function extract_block(string $css, string $selector): string
{
    $pos = strpos($css, $selector);
    if ($pos === false) return '';

    $open = strpos($css, '{', $pos);
    if ($open === false) return '';

    $depth = 0;
    $end = $open;
    $len = strlen($css);
    for ($i = $open; $i < $len; $i++) {
        if ($css[$i] === '{') $depth++;
        if ($css[$i] === '}') {
            $depth--;
            if ($depth === 0) {
                $end = $i;
                break;
            }
        }
    }

    return substr($css, $pos, $end - $pos + 1);
}

function extract_range(string $css, string $start_marker, string $end_marker): string
{
    $start = strpos($css, $start_marker);
    if ($start === false) return '';

    $end = strpos($css, $end_marker, $start + strlen($start_marker));
    if ($end === false) {
        return substr($css, $start);
    }

    return substr($css, $start, $end - $start);
}

function extract_media_rules(string $css, string $breakpoint, array $selectors): string
{
    // Find all @media blocks for this breakpoint
    $pattern = '/@media\s*\(max-width:\s*' . preg_quote($breakpoint) . '\)/';
    $result = '';

    if (preg_match_all($pattern, $css, $matches, PREG_OFFSET_CAPTURE)) {
        foreach ($matches[0] as $match) {
            $pos = $match[1];
            $open = strpos($css, '{', $pos);
            if ($open === false) continue;

            // Find matching close brace
            $depth = 0;
            $end = $open;
            $len = strlen($css);
            for ($i = $open; $i < $len; $i++) {
                if ($css[$i] === '{') $depth++;
                if ($css[$i] === '}') {
                    $depth--;
                    if ($depth === 0) {
                        $end = $i;
                        break;
                    }
                }
            }

            $block = substr($css, $open + 1, $end - $open - 1);

            // Extract only rules matching our selectors
            foreach ($selectors as $sel) {
                $sel_escaped = preg_quote($sel, '/');
                if (preg_match_all('/(' . $sel_escaped . '[^{]*\{[^}]*\})/s', $block, $rule_matches)) {
                    foreach ($rule_matches[1] as $rule) {
                        $result .= "    " . trim($rule) . "\n\n";
                    }
                }
            }
        }
    }

    return $result;
}
